
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { processCustomSyntax } from '../../src/components/markdown/customSyntaxProcessor';

export interface CompilerOptions {
  inputDir: string;
  outputDir: string;
}

export class SimpleMarkdownCompiler {
  private options: CompilerOptions;

  constructor(options: CompilerOptions) {
    this.options = options;
  }

  async compile(): Promise<void> {
    // Clean output directory
    if (fs.existsSync(this.options.outputDir)) {
      fs.rmSync(this.options.outputDir, { recursive: true });
    }
    fs.mkdirSync(this.options.outputDir, { recursive: true });

    // Process all markdown files
    const contentMap: Record<string, any> = {};
    await this.processDirectory(this.options.inputDir, '', contentMap);

    // Generate the index file with all compiled content
    await this.generateIndexFile(contentMap);

    console.log(`üì¶ Compiled ${Object.keys(contentMap).length} content files`);
  }

  private async processDirectory(
    dir: string,
    relativePath: string,
    contentMap: Record<string, any>
  ): Promise<void> {
    const items = fs.readdirSync(dir);

    for (const item of items) {
      const itemPath = path.join(dir, item);
      const stat = fs.statSync(itemPath);

      if (stat.isDirectory()) {
        await this.processDirectory(itemPath, path.join(relativePath, item), contentMap);
      } else if (item.endsWith('.md') || item.endsWith('.mdx')) {
        await this.processMarkdownFile(itemPath, relativePath, item, contentMap);
      }
    }
  }

  private async processMarkdownFile(
    filePath: string,
    relativePath: string,
    fileName: string,
    contentMap: Record<string, any>
  ): Promise<void> {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const { data: frontmatter, content: markdown } = matter(content);

      // Skip if not public
      if (frontmatter.visibility && frontmatter.visibility !== 'PUBLIC') {
        return;
      }

      // Generate the path key
      const baseName = fileName.replace(/\.(md|mdx)$/, '');
      let pathKey: string;
      
      if (relativePath) {
        pathKey = `/docs/${relativePath}/${baseName}`.replace(/\\/g, '/');
      } else {
        pathKey = `/docs/${baseName}`;
      }

      // Use frontmatter path if available
      if (frontmatter.path) {
        pathKey = frontmatter.path.startsWith('/') ? frontmatter.path : `/${frontmatter.path}`;
      }

      // Process the markdown content
      const processedContent = processCustomSyntax(markdown.trim());

      // Store in content map - we'll generate a single index file
      contentMap[pathKey] = {
        frontmatter: {
          title: frontmatter.title || baseName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
          description: frontmatter.description || null,
          author: frontmatter.author || null,
          lastModified: frontmatter.lastModified || null,
          path: pathKey,
          visibility: frontmatter.visibility || 'PUBLIC'
        },
        content: processedContent
      };

      console.log(`‚úì Processed: ${pathKey}`);
    } catch (error) {
      console.error(`‚úó Error processing ${filePath}:`, error);
    }
  }

  private async generateIndexFile(contentMap: Record<string, any>): Promise<void> {
    const indexContent = `// Auto-generated compiled content index
// This file is generated by the MDX compiler - do not edit manually

import React from 'react';
import { MarkdownRenderer } from '../components/MarkdownRenderer';

// Content data
const CONTENT_DATA = ${JSON.stringify(contentMap, null, 2)};

// Generate React components for each content piece
const contentRegistry = {};

Object.keys(CONTENT_DATA).forEach(path => {
  const data = CONTENT_DATA[path];
  
  contentRegistry[path] = {
    default: function CompiledContent() {
      return React.createElement(MarkdownRenderer, { content: data.content });
    },
    frontmatter: data.frontmatter
  };
});

export { contentRegistry };
export function getCompiledContent(path) {
  return contentRegistry[path] || null;
}
export function registerContent(path, module) {
  contentRegistry[path] = module;
}
`;

    const indexPath = path.join(this.options.outputDir, 'index.js');
    fs.writeFileSync(indexPath, indexContent);
    
    console.log('üìù Generated compiled content index');
  }
}
